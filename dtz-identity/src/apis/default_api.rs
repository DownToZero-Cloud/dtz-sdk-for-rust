/*
 * DTZ Identity
 *
 * a generated client for the DTZ Identity API
 *
 * Contact: jens@apimeister.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
#[allow(unused_imports)]
use serde::{de::Error as _};
use crate::{apis::ResponseContent, models};
#[allow(unused_imports)]
use super::{Error, ContentType};
use dtz_config::Configuration;

fn build_url(config: &Configuration) -> String {
    if let Some(base_path) = &config.base_path {
        let base = url::Url::parse(base_path).unwrap();
        let mut target_url = url::Url::parse(crate::apis::SVC_URL).unwrap();
        let _ = target_url.set_scheme(base.scheme());
        let _ = target_url.set_port(base.port());
        let _ = target_url.set_host(Some(base.host_str().unwrap()));
        format!("{target_url}")
    } else {
        crate::apis::SVC_URL.to_string()
    }
}


/// struct for typed errors of method [`assign_concrete_role`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AssignConcreteRoleError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`assume_identity`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AssumeIdentityError {
    Status401(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`authenticate_apikey`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthenticateApikeyError {
    Status401(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`change_authentication`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChangeAuthenticationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`check_identity`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CheckIdentityError {
    Status401(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_api_key`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateApiKeyError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_concrete_role_for_context`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateConcreteRoleForContextError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_api_key`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteApiKeyError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_context_roles`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteContextRolesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_identity`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteIdentityError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_abstract_roles`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAbstractRolesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_account_email`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAccountEmailError {
    Status404(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_account_stats`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAccountStatsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_concrete_roles_for_context`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetConcreteRolesForContextError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_concrete_roles_for_identity`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetConcreteRolesForIdentityError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_authentication`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListAuthenticationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_available_contexts`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListAvailableContextsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_identity`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListIdentityError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`new_context`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum NewContextError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`new_identity`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum NewIdentityError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`oauth_authorize`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OauthAuthorizeError {
    Status401(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`oauth_authorize_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OauthAuthorizePostError {
    Status401(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`oauth_register`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OauthRegisterError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`oauth_token`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OauthTokenError {
    Status400(models::ErrorResponse),
    Status401(models::ErrorResponse),
    Status500(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`oauth_userinfo`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OauthUserinfoError {
    Status401(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`share_concrete_role`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ShareConcreteRoleError {
    Status401(),
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`token_refresh`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TokenRefreshError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`unassign_concrete_role`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UnassignConcreteRoleError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_api_key_alias`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateApiKeyAliasError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`user_login`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UserLoginError {
    Status401(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`user_signup`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UserSignupError {
    Status409(models::ErrorResponse),
    Status400(models::ErrorResponse),
    Status500(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}


pub async fn assign_concrete_role(configuration: &Configuration, role_id: &str) -> Result<(), Error<AssignConcreteRoleError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_role_id = role_id;

    let uri_str = format!("{}/me/roles/{roleId}", build_url(configuration), roleId=crate::apis::urlencode(p_path_role_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);


    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref value) = configuration.api_key {
        req_builder = req_builder.header("X-API-KEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AssignConcreteRoleError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn assume_identity(configuration: &Configuration, assume_identity_request: Option<models::AssumeIdentityRequest>) -> Result<models::TokenResponse, Error<AssumeIdentityError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_assume_identity_request = assume_identity_request;

    let uri_str = format!("{}/identity/assume", build_url(configuration));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);


    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref value) = configuration.api_key {
        req_builder = req_builder.header("X-API-KEY", value);
    };
    req_builder = req_builder.json(&p_body_assume_identity_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TokenResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TokenResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AssumeIdentityError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn authenticate_apikey(configuration: &Configuration, apikey_request: Option<models::ApikeyRequest>) -> Result<models::TokenResponse, Error<AuthenticateApikeyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_apikey_request = apikey_request;

    let uri_str = format!("{}/auth/apikey", build_url(configuration));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);


    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref value) = configuration.api_key {
        req_builder = req_builder.header("X-API-KEY", value);
    };
    req_builder = req_builder.json(&p_body_apikey_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TokenResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TokenResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AuthenticateApikeyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn change_authentication(configuration: &Configuration, change_authentication_request: Option<models::ChangeAuthenticationRequest>) -> Result<(), Error<ChangeAuthenticationError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_change_authentication_request = change_authentication_request;

    let uri_str = format!("{}/authentication", build_url(configuration));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);


    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref value) = configuration.api_key {
        req_builder = req_builder.header("X-API-KEY", value);
    };
    req_builder = req_builder.json(&p_body_change_authentication_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ChangeAuthenticationError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn check_identity(configuration: &Configuration, check_identity_request: Option<models::CheckIdentityRequest>) -> Result<models::CheckIdentity200Response, Error<CheckIdentityError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_check_identity_request = check_identity_request;

    let uri_str = format!("{}/identity/check", build_url(configuration));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);


    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref value) = configuration.api_key {
        req_builder = req_builder.header("X-API-KEY", value);
    };
    req_builder = req_builder.json(&p_body_check_identity_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CheckIdentity200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CheckIdentity200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CheckIdentityError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn create_api_key(configuration: &Configuration, create_api_key_request: models::CreateApiKeyRequest) -> Result<String, Error<CreateApiKeyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_create_api_key_request = create_api_key_request;

    let uri_str = format!("{}/me/identity/apikey", build_url(configuration));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);


    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref value) = configuration.api_key {
        req_builder = req_builder.header("X-API-KEY", value);
    };
    req_builder = req_builder.json(&p_body_create_api_key_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Ok(content),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `String`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateApiKeyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn create_concrete_role_for_context(configuration: &Configuration, context_id: &str, create_concrete_role_for_context_request: Option<models::CreateConcreteRoleForContextRequest>) -> Result<models::ContextRole, Error<CreateConcreteRoleForContextError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_context_id = context_id;
    let p_body_create_concrete_role_for_context_request = create_concrete_role_for_context_request;

    let uri_str = format!("{}/roles/context/{contextId}", build_url(configuration), contextId=crate::apis::urlencode(p_path_context_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);


    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref value) = configuration.api_key {
        req_builder = req_builder.header("X-API-KEY", value);
    };
    req_builder = req_builder.json(&p_body_create_concrete_role_for_context_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ContextRole`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ContextRole`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateConcreteRoleForContextError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn delete_api_key(configuration: &Configuration, apikey: &str) -> Result<(), Error<DeleteApiKeyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_apikey = apikey;

    let uri_str = format!("{}/me/identity/apikey/{apikey}", build_url(configuration), apikey=crate::apis::urlencode(p_path_apikey));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);


    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref value) = configuration.api_key {
        req_builder = req_builder.header("X-API-KEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteApiKeyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn delete_context_roles(configuration: &Configuration, context_id: &str) -> Result<(), Error<DeleteContextRolesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_context_id = context_id;

    let uri_str = format!("{}/context/{context_id}", build_url(configuration), context_id=crate::apis::urlencode(p_path_context_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);


    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref value) = configuration.api_key {
        req_builder = req_builder.header("X-API-KEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteContextRolesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn delete_identity(configuration: &Configuration) -> Result<(), Error<DeleteIdentityError>> {

    let uri_str = format!("{}/me/identity", build_url(configuration));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);


    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref value) = configuration.api_key {
        req_builder = req_builder.header("X-API-KEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteIdentityError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_abstract_roles(configuration: &Configuration) -> Result<models::GetAbstractRoles200Response, Error<GetAbstractRolesError>> {

    let uri_str = format!("{}/roles", build_url(configuration));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);


    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref value) = configuration.api_key {
        req_builder = req_builder.header("X-API-KEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetAbstractRoles200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetAbstractRoles200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAbstractRolesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_account_email(configuration: &Configuration) -> Result<models::GetAccountEmail200Response, Error<GetAccountEmailError>> {

    let uri_str = format!("{}/me/email", build_url(configuration));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);


    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref value) = configuration.api_key {
        req_builder = req_builder.header("X-API-KEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetAccountEmail200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetAccountEmail200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAccountEmailError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_account_stats(configuration: &Configuration) -> Result<models::GetAccountStats200Response, Error<GetAccountStatsError>> {

    let uri_str = format!("{}/me", build_url(configuration));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);


    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref value) = configuration.api_key {
        req_builder = req_builder.header("X-API-KEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetAccountStats200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetAccountStats200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAccountStatsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_concrete_roles_for_context(configuration: &Configuration, context_id: &str) -> Result<models::GetConcreteRolesForContext200Response, Error<GetConcreteRolesForContextError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_context_id = context_id;

    let uri_str = format!("{}/roles/context/{contextId}", build_url(configuration), contextId=crate::apis::urlencode(p_path_context_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);


    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref value) = configuration.api_key {
        req_builder = req_builder.header("X-API-KEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetConcreteRolesForContext200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetConcreteRolesForContext200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetConcreteRolesForContextError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_concrete_roles_for_identity(configuration: &Configuration, identity_id: &str) -> Result<models::GetConcreteRolesForIdentity200Response, Error<GetConcreteRolesForIdentityError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_identity_id = identity_id;

    let uri_str = format!("{}/roles/identity/{identityId}", build_url(configuration), identityId=crate::apis::urlencode(p_path_identity_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);


    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref value) = configuration.api_key {
        req_builder = req_builder.header("X-API-KEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetConcreteRolesForIdentity200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetConcreteRolesForIdentity200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetConcreteRolesForIdentityError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn list_authentication(configuration: &Configuration) -> Result<models::ListAuthentication200Response, Error<ListAuthenticationError>> {

    let uri_str = format!("{}/authentication", build_url(configuration));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);


    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref value) = configuration.api_key {
        req_builder = req_builder.header("X-API-KEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ListAuthentication200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ListAuthentication200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListAuthenticationError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn list_available_contexts(configuration: &Configuration) -> Result<Vec<models::ListAvailableContexts200ResponseInner>, Error<ListAvailableContextsError>> {

    let uri_str = format!("{}/context", build_url(configuration));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);


    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref value) = configuration.api_key {
        req_builder = req_builder.header("X-API-KEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::ListAvailableContexts200ResponseInner&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::ListAvailableContexts200ResponseInner&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListAvailableContextsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn list_identity(configuration: &Configuration) -> Result<models::ListIdentity200Response, Error<ListIdentityError>> {

    let uri_str = format!("{}/identity", build_url(configuration));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);


    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref value) = configuration.api_key {
        req_builder = req_builder.header("X-API-KEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ListIdentity200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ListIdentity200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListIdentityError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn new_context(configuration: &Configuration, context_id: &str, new_context_request: Option<models::NewContextRequest>) -> Result<(), Error<NewContextError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_context_id = context_id;
    let p_body_new_context_request = new_context_request;

    let uri_str = format!("{}/context/{context_id}/new", build_url(configuration), context_id=crate::apis::urlencode(p_path_context_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);


    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref value) = configuration.api_key {
        req_builder = req_builder.header("X-API-KEY", value);
    };
    req_builder = req_builder.json(&p_body_new_context_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<NewContextError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn new_identity(configuration: &Configuration, new_identity_request: Option<models::NewIdentityRequest>) -> Result<models::ListIdentity200ResponseIdentitiesInner, Error<NewIdentityError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_new_identity_request = new_identity_request;

    let uri_str = format!("{}/identity", build_url(configuration));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);


    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref value) = configuration.api_key {
        req_builder = req_builder.header("X-API-KEY", value);
    };
    req_builder = req_builder.json(&p_body_new_identity_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ListIdentity200ResponseIdentitiesInner`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ListIdentity200ResponseIdentitiesInner`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<NewIdentityError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn oauth_authorize(configuration: &Configuration, response_type: &str, client_id: &str, redirect_uri: &str, scope: &str, state: Option<&str>, nonce: Option<&str>) -> Result<reqwest::header::HeaderMap, Error<OauthAuthorizeError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_response_type = response_type;
    let p_query_client_id = client_id;
    let p_query_redirect_uri = redirect_uri;
    let p_query_scope = scope;
    let p_query_state = state;
    let p_query_nonce = nonce;

    let uri_str = format!("{}/oauth/authorize", build_url(configuration));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);


    req_builder = req_builder.query(&[("response_type", &p_query_response_type.to_string())]);
    req_builder = req_builder.query(&[("client_id", &p_query_client_id.to_string())]);
    req_builder = req_builder.query(&[("redirect_uri", &p_query_redirect_uri.to_string())]);
    req_builder = req_builder.query(&[("scope", &p_query_scope.to_string())]);
    if let Some(ref param_value) = p_query_state {
        req_builder = req_builder.query(&[("state", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_nonce {
        req_builder = req_builder.query(&[("nonce", &param_value.to_string())]);
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref value) = configuration.api_key {
        req_builder = req_builder.header("X-API-KEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let headers = resp.headers().clone();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(headers)
    } else {
        let content = resp.text().await?;
        let entity: Option<OauthAuthorizeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn oauth_authorize_post(configuration: &Configuration, response_type: &str, client_id: &str, redirect_uri: &str, scope: &str, state: Option<&str>, nonce: Option<&str>) -> Result<reqwest::header::HeaderMap, Error<OauthAuthorizePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_response_type = response_type;
    let p_query_client_id = client_id;
    let p_query_redirect_uri = redirect_uri;
    let p_query_scope = scope;
    let p_query_state = state;
    let p_query_nonce = nonce;

    let uri_str = format!("{}/oauth/authorize", build_url(configuration));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);


    req_builder = req_builder.query(&[("response_type", &p_query_response_type.to_string())]);
    req_builder = req_builder.query(&[("client_id", &p_query_client_id.to_string())]);
    req_builder = req_builder.query(&[("redirect_uri", &p_query_redirect_uri.to_string())]);
    req_builder = req_builder.query(&[("scope", &p_query_scope.to_string())]);
    if let Some(ref param_value) = p_query_state {
        req_builder = req_builder.query(&[("state", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_nonce {
        req_builder = req_builder.query(&[("nonce", &param_value.to_string())]);
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref value) = configuration.api_key {
        req_builder = req_builder.header("X-API-KEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let headers = resp.headers().clone();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(headers)
    } else {
        let content = resp.text().await?;
        let entity: Option<OauthAuthorizePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// register a new oauth client application
pub async fn oauth_register(configuration: &Configuration, oauth_register_request: models::OauthRegisterRequest) -> Result<models::OauthRegister200Response, Error<OauthRegisterError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_oauth_register_request = oauth_register_request;

    let uri_str = format!("{}/oauth/register", build_url(configuration));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);


    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref value) = configuration.api_key {
        req_builder = req_builder.header("X-API-KEY", value);
    };
    req_builder = req_builder.json(&p_body_oauth_register_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OauthRegister200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OauthRegister200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OauthRegisterError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// oauth token request
pub async fn oauth_token(configuration: &Configuration, grant_type: &str, client_id: &str, client_secret: &str, redirect_uri: &str, code: &str) -> Result<models::TokenResponse, Error<OauthTokenError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_form_grant_type = grant_type;
    let p_form_client_id = client_id;
    let p_form_client_secret = client_secret;
    let p_form_redirect_uri = redirect_uri;
    let p_form_code = code;

    let uri_str = format!("{}/oauth/token", build_url(configuration));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);


    let mut multipart_form_params = std::collections::HashMap::new();
    multipart_form_params.insert("grant_type", p_form_grant_type.to_string());
    multipart_form_params.insert("client_id", p_form_client_id.to_string());
    multipart_form_params.insert("client_secret", p_form_client_secret.to_string());
    multipart_form_params.insert("redirect_uri", p_form_redirect_uri.to_string());
    multipart_form_params.insert("code", p_form_code.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TokenResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TokenResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OauthTokenError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// returns the decoded JWT token content containing user information
pub async fn oauth_userinfo(configuration: &Configuration) -> Result<std::collections::HashMap<String, serde_json::Value>, Error<OauthUserinfoError>> {

    let uri_str = format!("{}/oauth/userinfo", build_url(configuration));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);


    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref value) = configuration.api_key {
        req_builder = req_builder.header("X-API-KEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `std::collections::HashMap&lt;String, serde_json::Value&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `std::collections::HashMap&lt;String, serde_json::Value&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OauthUserinfoError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn share_concrete_role(configuration: &Configuration, role_id: &str, check_identity_request: models::CheckIdentityRequest) -> Result<(), Error<ShareConcreteRoleError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_role_id = role_id;
    let p_body_check_identity_request = check_identity_request;

    let uri_str = format!("{}/roles/{roleId}/share", build_url(configuration), roleId=crate::apis::urlencode(p_path_role_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);


    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref value) = configuration.api_key {
        req_builder = req_builder.header("X-API-KEY", value);
    };
    req_builder = req_builder.json(&p_body_check_identity_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ShareConcreteRoleError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// token refresh
pub async fn token_refresh(configuration: &Configuration, change_context_request: models::ChangeContextRequest) -> Result<models::TokenResponse, Error<TokenRefreshError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_change_context_request = change_context_request;

    let uri_str = format!("{}/token/refresh", build_url(configuration));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);


    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref value) = configuration.api_key {
        req_builder = req_builder.header("X-API-KEY", value);
    };
    req_builder = req_builder.json(&p_body_change_context_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TokenResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TokenResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TokenRefreshError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn unassign_concrete_role(configuration: &Configuration, role_id: &str) -> Result<(), Error<UnassignConcreteRoleError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_role_id = role_id;

    let uri_str = format!("{}/me/roles/{roleId}", build_url(configuration), roleId=crate::apis::urlencode(p_path_role_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);


    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref value) = configuration.api_key {
        req_builder = req_builder.header("X-API-KEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<UnassignConcreteRoleError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn update_api_key_alias(configuration: &Configuration, apikey: &str, update_api_key_alias_request: Option<models::UpdateApiKeyAliasRequest>) -> Result<(), Error<UpdateApiKeyAliasError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_apikey = apikey;
    let p_body_update_api_key_alias_request = update_api_key_alias_request;

    let uri_str = format!("{}/me/identity/apikey/{apikey}", build_url(configuration), apikey=crate::apis::urlencode(p_path_apikey));
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);


    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref value) = configuration.api_key {
        req_builder = req_builder.header("X-API-KEY", value);
    };
    req_builder = req_builder.json(&p_body_update_api_key_alias_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateApiKeyAliasError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn user_login(configuration: &Configuration, auth_request: models::AuthRequest) -> Result<models::TokenResponse, Error<UserLoginError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_auth_request = auth_request;

    let uri_str = format!("{}/token/auth", build_url(configuration));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);


    req_builder = req_builder.json(&p_body_auth_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TokenResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TokenResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UserLoginError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn user_signup(configuration: &Configuration, signup_request: models::SignupRequest) -> Result<models::TokenResponse, Error<UserSignupError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_signup_request = signup_request;

    let uri_str = format!("{}/signup", build_url(configuration));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);


    req_builder = req_builder.json(&p_body_signup_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TokenResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TokenResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UserSignupError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

