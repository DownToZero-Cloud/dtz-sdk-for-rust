/*
 * DTZ Identity
 *
 * a generated client for the DTZ Identity API
 *
 * The version of the OpenAPI document: 1.0.26
 * Contact: jens@apimeister.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
#[allow(unused_imports)]
use serde::{de::Error as _};
use crate::{apis::ResponseContent, models};
#[allow(unused_imports)]
use super::{Error, ContentType};
use dtz_config::Configuration;

fn build_url(config: &Configuration) -> String {
    if let Some(base_path) = &config.base_path {
        let base = url::Url::parse(base_path).unwrap();
        let mut target_url = url::Url::parse(crate::apis::SVC_URL).unwrap();
        let _ = target_url.set_scheme(base.scheme());
        let _ = target_url.set_port(base.port());
        let _ = target_url.set_host(Some(base.host_str().unwrap()));
        format!("{target_url}")
    } else {
        crate::apis::SVC_URL.to_string()
    }
}


/// struct for typed errors of method [`assign_role`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AssignRoleError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`assume_identity`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AssumeIdentityError {
    Status401(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`authenticate_apikey`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthenticateApikeyError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`change_authentication`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChangeAuthenticationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`check_identity`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CheckIdentityError {
    Status401(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_api_key`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateApiKeyError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_api_key`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteApiKeyError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_context_roles`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteContextRolesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_identity`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteIdentityError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_abstract_roles`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAbstractRolesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_account_email`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAccountEmailError {
    Status404(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_account_stats`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAccountStatsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_roles_for_context`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRolesForContextError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_roles_for_identity`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRolesForIdentityError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_authentication`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListAuthenticationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_available_contexts`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListAvailableContextsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_identity`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListIdentityError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`new_context`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum NewContextError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`new_identity`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum NewIdentityError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`oauth_authorize`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OauthAuthorizeError {
    Status401(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`oauth_token`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OauthTokenError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`remove_role_assignment`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RemoveRoleAssignmentError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`share_role`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ShareRoleError {
    Status401(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`token_refresh`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TokenRefreshError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`user_login`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UserLoginError {
    Status401(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`user_signup`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UserSignupError {
    Status500(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}


pub async fn assign_role(configuration: &Configuration, role_id: &str) -> Result<(), Error<AssignRoleError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_role_id = role_id;

    let uri_str = format!("{}/me/roles/{roleId}", build_url(configuration), roleId=crate::apis::urlencode(p_role_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref value) = configuration.api_key {
        req_builder = req_builder.header("X-API-KEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AssignRoleError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn assume_identity(configuration: &Configuration, assume_identity_request: Option<models::AssumeIdentityRequest>) -> Result<models::TokenResponse, Error<AssumeIdentityError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_assume_identity_request = assume_identity_request;

    let uri_str = format!("{}/identity/assume", build_url(configuration));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref value) = configuration.api_key {
        req_builder = req_builder.header("X-API-KEY", value);
    };
    req_builder = req_builder.json(&p_assume_identity_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TokenResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TokenResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AssumeIdentityError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn authenticate_apikey(configuration: &Configuration, apikey_request: Option<models::ApikeyRequest>) -> Result<models::TokenResponse, Error<AuthenticateApikeyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_apikey_request = apikey_request;

    let uri_str = format!("{}/auth/apikey", build_url(configuration));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref value) = configuration.api_key {
        req_builder = req_builder.header("X-API-KEY", value);
    };
    req_builder = req_builder.json(&p_apikey_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TokenResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TokenResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AuthenticateApikeyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn change_authentication(configuration: &Configuration, change_authentication_request: Option<models::ChangeAuthenticationRequest>) -> Result<(), Error<ChangeAuthenticationError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_change_authentication_request = change_authentication_request;

    let uri_str = format!("{}/authentication", build_url(configuration));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref value) = configuration.api_key {
        req_builder = req_builder.header("X-API-KEY", value);
    };
    req_builder = req_builder.json(&p_change_authentication_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ChangeAuthenticationError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn check_identity(configuration: &Configuration, check_identity_request: Option<models::CheckIdentityRequest>) -> Result<models::CheckIdentity200Response, Error<CheckIdentityError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_check_identity_request = check_identity_request;

    let uri_str = format!("{}/identity/check", build_url(configuration));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref value) = configuration.api_key {
        req_builder = req_builder.header("X-API-KEY", value);
    };
    req_builder = req_builder.json(&p_check_identity_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CheckIdentity200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CheckIdentity200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CheckIdentityError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn create_api_key(configuration: &Configuration, create_api_key_request: models::CreateApiKeyRequest) -> Result<String, Error<CreateApiKeyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_create_api_key_request = create_api_key_request;

    let uri_str = format!("{}/me/identity/apikey", build_url(configuration));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref value) = configuration.api_key {
        req_builder = req_builder.header("X-API-KEY", value);
    };
    req_builder = req_builder.json(&p_create_api_key_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Ok(content),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `String`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateApiKeyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn delete_api_key(configuration: &Configuration, apikey: &str) -> Result<(), Error<DeleteApiKeyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_apikey = apikey;

    let uri_str = format!("{}/me/identity/apikey/{apikey}", build_url(configuration), apikey=crate::apis::urlencode(p_apikey));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref value) = configuration.api_key {
        req_builder = req_builder.header("X-API-KEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteApiKeyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn delete_context_roles(configuration: &Configuration, context_id: &str) -> Result<(), Error<DeleteContextRolesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_context_id = context_id;

    let uri_str = format!("{}/context/{context_id}", build_url(configuration), context_id=crate::apis::urlencode(p_context_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref value) = configuration.api_key {
        req_builder = req_builder.header("X-API-KEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteContextRolesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn delete_identity(configuration: &Configuration, ) -> Result<(), Error<DeleteIdentityError>> {

    let uri_str = format!("{}/me/identity", build_url(configuration));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref value) = configuration.api_key {
        req_builder = req_builder.header("X-API-KEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteIdentityError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_abstract_roles(configuration: &Configuration, ) -> Result<models::GetAbstractRoles200Response, Error<GetAbstractRolesError>> {

    let uri_str = format!("{}/roles", build_url(configuration));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref value) = configuration.api_key {
        req_builder = req_builder.header("X-API-KEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetAbstractRoles200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetAbstractRoles200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAbstractRolesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_account_email(configuration: &Configuration, ) -> Result<models::GetAccountEmail200Response, Error<GetAccountEmailError>> {

    let uri_str = format!("{}/me/email", build_url(configuration));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref value) = configuration.api_key {
        req_builder = req_builder.header("X-API-KEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetAccountEmail200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetAccountEmail200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAccountEmailError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_account_stats(configuration: &Configuration, ) -> Result<models::GetAccountStats200Response, Error<GetAccountStatsError>> {

    let uri_str = format!("{}/me", build_url(configuration));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref value) = configuration.api_key {
        req_builder = req_builder.header("X-API-KEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetAccountStats200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetAccountStats200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAccountStatsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_roles_for_context(configuration: &Configuration, context_id: &str) -> Result<models::GetRolesForContext200Response, Error<GetRolesForContextError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_context_id = context_id;

    let uri_str = format!("{}/roles/context/{contextId}", build_url(configuration), contextId=crate::apis::urlencode(p_context_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref value) = configuration.api_key {
        req_builder = req_builder.header("X-API-KEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetRolesForContext200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetRolesForContext200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetRolesForContextError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_roles_for_identity(configuration: &Configuration, identity_id: &str) -> Result<models::GetRolesForIdentity200Response, Error<GetRolesForIdentityError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_identity_id = identity_id;

    let uri_str = format!("{}/roles/identity/{identityId}", build_url(configuration), identityId=crate::apis::urlencode(p_identity_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref value) = configuration.api_key {
        req_builder = req_builder.header("X-API-KEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetRolesForIdentity200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetRolesForIdentity200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetRolesForIdentityError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn list_authentication(configuration: &Configuration, ) -> Result<models::ListAuthentication200Response, Error<ListAuthenticationError>> {

    let uri_str = format!("{}/authentication", build_url(configuration));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref value) = configuration.api_key {
        req_builder = req_builder.header("X-API-KEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ListAuthentication200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ListAuthentication200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListAuthenticationError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn list_available_contexts(configuration: &Configuration, ) -> Result<Vec<models::ListAvailableContexts200ResponseInner>, Error<ListAvailableContextsError>> {

    let uri_str = format!("{}/context", build_url(configuration));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref value) = configuration.api_key {
        req_builder = req_builder.header("X-API-KEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::ListAvailableContexts200ResponseInner&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::ListAvailableContexts200ResponseInner&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListAvailableContextsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn list_identity(configuration: &Configuration, ) -> Result<models::ListIdentity200Response, Error<ListIdentityError>> {

    let uri_str = format!("{}/identity", build_url(configuration));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref value) = configuration.api_key {
        req_builder = req_builder.header("X-API-KEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ListIdentity200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ListIdentity200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListIdentityError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn new_context(configuration: &Configuration, context_id: &str, new_context_request: Option<models::NewContextRequest>) -> Result<(), Error<NewContextError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_context_id = context_id;
    let p_new_context_request = new_context_request;

    let uri_str = format!("{}/context/{context_id}/new", build_url(configuration), context_id=crate::apis::urlencode(p_context_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref value) = configuration.api_key {
        req_builder = req_builder.header("X-API-KEY", value);
    };
    req_builder = req_builder.json(&p_new_context_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<NewContextError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn new_identity(configuration: &Configuration, new_identity_request: Option<models::NewIdentityRequest>) -> Result<models::ListIdentity200ResponseIdentitiesInner, Error<NewIdentityError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_new_identity_request = new_identity_request;

    let uri_str = format!("{}/identity", build_url(configuration));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref value) = configuration.api_key {
        req_builder = req_builder.header("X-API-KEY", value);
    };
    req_builder = req_builder.json(&p_new_identity_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ListIdentity200ResponseIdentitiesInner`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ListIdentity200ResponseIdentitiesInner`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<NewIdentityError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn oauth_authorize(configuration: &Configuration, response_type: &str, client_id: &str, redirect_uri: &str, scope: &str, state: Option<&str>, nonce: Option<&str>) -> Result<reqwest::header::HeaderMap, Error<OauthAuthorizeError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_response_type = response_type;
    let p_client_id = client_id;
    let p_redirect_uri = redirect_uri;
    let p_scope = scope;
    let p_state = state;
    let p_nonce = nonce;

    let uri_str = format!("{}/oauth/authorize", build_url(configuration));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("response_type", &p_response_type.to_string())]);
    req_builder = req_builder.query(&[("client_id", &p_client_id.to_string())]);
    req_builder = req_builder.query(&[("redirect_uri", &p_redirect_uri.to_string())]);
    req_builder = req_builder.query(&[("scope", &p_scope.to_string())]);
    if let Some(ref param_value) = p_state {
        req_builder = req_builder.query(&[("state", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_nonce {
        req_builder = req_builder.query(&[("nonce", &param_value.to_string())]);
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref value) = configuration.api_key {
        req_builder = req_builder.header("X-API-KEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let headers = resp.headers().clone();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(headers)
    } else {
        let content = resp.text().await?;
        let entity: Option<OauthAuthorizeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// oauth token request
pub async fn oauth_token(configuration: &Configuration, grant_type: &str, client_id: &str, client_secret: &str, redirect_uri: &str, code: &str) -> Result<models::TokenResponse, Error<OauthTokenError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_grant_type = grant_type;
    let p_client_id = client_id;
    let p_client_secret = client_secret;
    let p_redirect_uri = redirect_uri;
    let p_code = code;

    let uri_str = format!("{}/oauth/token", build_url(configuration));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    let mut multipart_form_params = std::collections::HashMap::new();
    multipart_form_params.insert("grant_type", p_grant_type.to_string());
    multipart_form_params.insert("client_id", p_client_id.to_string());
    multipart_form_params.insert("client_secret", p_client_secret.to_string());
    multipart_form_params.insert("redirect_uri", p_redirect_uri.to_string());
    multipart_form_params.insert("code", p_code.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TokenResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TokenResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OauthTokenError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn remove_role_assignment(configuration: &Configuration, role_id: &str) -> Result<(), Error<RemoveRoleAssignmentError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_role_id = role_id;

    let uri_str = format!("{}/me/roles/{roleId}", build_url(configuration), roleId=crate::apis::urlencode(p_role_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref value) = configuration.api_key {
        req_builder = req_builder.header("X-API-KEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<RemoveRoleAssignmentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn share_role(configuration: &Configuration, context_id: &str, role_id: &str, check_identity_request: models::CheckIdentityRequest) -> Result<(), Error<ShareRoleError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_context_id = context_id;
    let p_role_id = role_id;
    let p_check_identity_request = check_identity_request;

    let uri_str = format!("{}/roles/context/{contextId}/{roleId}/share", build_url(configuration), contextId=crate::apis::urlencode(p_context_id), roleId=crate::apis::urlencode(p_role_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref value) = configuration.api_key {
        req_builder = req_builder.header("X-API-KEY", value);
    };
    req_builder = req_builder.json(&p_check_identity_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ShareRoleError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// token refresh
pub async fn token_refresh(configuration: &Configuration, change_context_request: models::ChangeContextRequest) -> Result<models::TokenResponse, Error<TokenRefreshError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_change_context_request = change_context_request;

    let uri_str = format!("{}/token/refresh", build_url(configuration));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref value) = configuration.api_key {
        req_builder = req_builder.header("X-API-KEY", value);
    };
    req_builder = req_builder.json(&p_change_context_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TokenResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TokenResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TokenRefreshError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn user_login(configuration: &Configuration, auth_request: models::AuthRequest) -> Result<models::TokenResponse, Error<UserLoginError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_auth_request = auth_request;

    let uri_str = format!("{}/token/auth", build_url(configuration));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.json(&p_auth_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TokenResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TokenResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UserLoginError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn user_signup(configuration: &Configuration, signup_request: models::SignupRequest) -> Result<models::TokenResponse, Error<UserSignupError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_signup_request = signup_request;

    let uri_str = format!("{}/signup", build_url(configuration));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.json(&p_signup_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TokenResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TokenResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UserSignupError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

