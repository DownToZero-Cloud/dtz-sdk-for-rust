/*
 * DTZ Core Api
 *
 * a generated client for the DTZ Core API
 *
 * Contact: jens@apimeister.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
#[allow(unused_imports)]
use serde::{de::Error as _};
use crate::{apis::ResponseContent, models};
#[allow(unused_imports)]
use super::{Error, ContentType};
use dtz_config::Configuration;

fn build_url(config: &Configuration) -> String {
    if let Some(base_path) = &config.base_path {
        let base = url::Url::parse(base_path).unwrap();
        let mut target_url = url::Url::parse(crate::apis::SVC_URL).unwrap();
        let _ = target_url.set_scheme(base.scheme());
        let _ = target_url.set_port(base.port());
        let _ = target_url.set_host(Some(base.host_str().unwrap()));
        format!("{target_url}")
    } else {
        crate::apis::SVC_URL.to_string()
    }
}


/// struct for typed successes of method [`create_chat`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateChatSuccess {
    Status200(models::ChatResponseMessage),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_context`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateContextSuccess {
    Status200(models::ContextResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_ingress`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateIngressSuccess {
    Status200(models::IngressResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_root_ingress`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateRootIngressSuccess {
    Status200(models::IngressResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_task`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateTaskSuccess {
    Status200(models::CreateTask200Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_context`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteContextSuccess {
    Status200(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_ingress`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteIngressSuccess {
    Status200(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_root_ingress`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteRootIngressSuccess {
    Status200(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`enable_service`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EnableServiceSuccess {
    Status200(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`get_chat`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetChatSuccess {
    Status200(models::Chat),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`get_context`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetContextSuccess {
    Status200(models::ContextResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`get_current_context`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetCurrentContextSuccess {
    Status200(models::ContextResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`get_ingress`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetIngressSuccess {
    Status200(models::IngressResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`get_root_ingress`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRootIngressSuccess {
    Status200(models::IngressResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`get_task_history`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTaskHistorySuccess {
    Status200(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`issue_certificate`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IssueCertificateSuccess {
    Status200(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_available_contexts`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListAvailableContextsSuccess {
    Status200(Vec<models::ContextResponse>),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_chat`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListChatSuccess {
    Status200(Vec<models::ListChat200ResponseInner>),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_ingress`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListIngressSuccess {
    Status200(Vec<models::IngressResponse>),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`pull_task_from_queue`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PullTaskFromQueueSuccess {
    Status200(models::PullTaskFromQueue200Response),
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`update_chat`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateChatSuccess {
    Status200(models::ChatResponseMessage),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`update_context`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateContextSuccess {
    Status200(models::ContextResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_chat`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateChatError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_context`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateContextError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_ingress`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateIngressError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_root_ingress`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateRootIngressError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_task`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateTaskError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_context`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteContextError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_ingress`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteIngressError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_root_ingress`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteRootIngressError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`enable_service`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EnableServiceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_chat`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetChatError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_context`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetContextError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_current_context`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetCurrentContextError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_ingress`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetIngressError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_root_ingress`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRootIngressError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_task_history`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTaskHistoryError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`issue_certificate`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IssueCertificateError {
    Status429(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_available_contexts`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListAvailableContextsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_chat`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListChatError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_ingress`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListIngressError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pull_task_from_queue`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PullTaskFromQueueError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_chat`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateChatError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_context`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateContextError {
    UnknownValue(serde_json::Value),
}


pub async fn create_chat(configuration: &Configuration, create_chat_request: Option<models::CreateChatRequest>) -> Result<ResponseContent<CreateChatSuccess>, Error<CreateChatError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_create_chat_request = create_chat_request;

    let uri_str = format!("{}/chat", build_url(configuration));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref value) = configuration.api_key {
        req_builder = req_builder.header("X-API-KEY", value);
    };
    req_builder = req_builder.json(&p_create_chat_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<CreateChatSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateChatError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// create new context
pub async fn create_context(configuration: &Configuration, create_context_request: Option<models::CreateContextRequest>) -> Result<ResponseContent<CreateContextSuccess>, Error<CreateContextError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_create_context_request = create_context_request;

    let uri_str = format!("{}/context", build_url(configuration));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref value) = configuration.api_key {
        req_builder = req_builder.header("X-API-KEY", value);
    };
    req_builder = req_builder.json(&p_create_context_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<CreateContextSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateContextError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn create_ingress(configuration: &Configuration, domain: &str, uri: &str, create_ingress_request: Option<models::CreateIngressRequest>) -> Result<ResponseContent<CreateIngressSuccess>, Error<CreateIngressError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_domain = domain;
    let p_uri = uri;
    let p_create_ingress_request = create_ingress_request;

    let uri_str = format!("{}/ingress/{domain}/{uri}", build_url(configuration), domain=crate::apis::urlencode(p_domain), uri=crate::apis::urlencode(p_uri));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref value) = configuration.api_key {
        req_builder = req_builder.header("X-API-KEY", value);
    };
    req_builder = req_builder.json(&p_create_ingress_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<CreateIngressSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateIngressError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn create_root_ingress(configuration: &Configuration, domain: &str, create_ingress_request: Option<models::CreateIngressRequest>) -> Result<ResponseContent<CreateRootIngressSuccess>, Error<CreateRootIngressError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_domain = domain;
    let p_create_ingress_request = create_ingress_request;

    let uri_str = format!("{}/ingress/{domain}/", build_url(configuration), domain=crate::apis::urlencode(p_domain));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref value) = configuration.api_key {
        req_builder = req_builder.header("X-API-KEY", value);
    };
    req_builder = req_builder.json(&p_create_ingress_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<CreateRootIngressSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateRootIngressError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn create_task(configuration: &Configuration, task_id: &str, create_task_request: Option<models::CreateTaskRequest>) -> Result<ResponseContent<CreateTaskSuccess>, Error<CreateTaskError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_task_id = task_id;
    let p_create_task_request = create_task_request;

    let uri_str = format!("{}/task/{task_id}", build_url(configuration), task_id=crate::apis::urlencode(p_task_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref value) = configuration.api_key {
        req_builder = req_builder.header("X-API-KEY", value);
    };
    req_builder = req_builder.json(&p_create_task_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<CreateTaskSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateTaskError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn delete_context(configuration: &Configuration, context_id: &str) -> Result<ResponseContent<DeleteContextSuccess>, Error<DeleteContextError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_context_id = context_id;

    let uri_str = format!("{}/context/{context_id}", build_url(configuration), context_id=crate::apis::urlencode(p_context_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref value) = configuration.api_key {
        req_builder = req_builder.header("X-API-KEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<DeleteContextSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteContextError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn delete_ingress(configuration: &Configuration, domain: &str, uri: &str) -> Result<ResponseContent<DeleteIngressSuccess>, Error<DeleteIngressError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_domain = domain;
    let p_uri = uri;

    let uri_str = format!("{}/ingress/{domain}/{uri}", build_url(configuration), domain=crate::apis::urlencode(p_domain), uri=crate::apis::urlencode(p_uri));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref value) = configuration.api_key {
        req_builder = req_builder.header("X-API-KEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<DeleteIngressSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteIngressError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn delete_root_ingress(configuration: &Configuration, domain: &str) -> Result<ResponseContent<DeleteRootIngressSuccess>, Error<DeleteRootIngressError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_domain = domain;

    let uri_str = format!("{}/ingress/{domain}/", build_url(configuration), domain=crate::apis::urlencode(p_domain));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref value) = configuration.api_key {
        req_builder = req_builder.header("X-API-KEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<DeleteRootIngressSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteRootIngressError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn enable_service(configuration: &Configuration, context_id: &str) -> Result<ResponseContent<EnableServiceSuccess>, Error<EnableServiceError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_context_id = context_id;

    let uri_str = format!("{}/context/{context_id}/enableService", build_url(configuration), context_id=crate::apis::urlencode(p_context_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref value) = configuration.api_key {
        req_builder = req_builder.header("X-API-KEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<EnableServiceSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<EnableServiceError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_chat(configuration: &Configuration, chat_id: &str) -> Result<ResponseContent<GetChatSuccess>, Error<GetChatError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_chat_id = chat_id;

    let uri_str = format!("{}/chat/{chat_id}", build_url(configuration), chat_id=crate::apis::urlencode(p_chat_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref value) = configuration.api_key {
        req_builder = req_builder.header("X-API-KEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<GetChatSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<GetChatError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_context(configuration: &Configuration, context_id: &str) -> Result<ResponseContent<GetContextSuccess>, Error<GetContextError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_context_id = context_id;

    let uri_str = format!("{}/context/{context_id}", build_url(configuration), context_id=crate::apis::urlencode(p_context_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref value) = configuration.api_key {
        req_builder = req_builder.header("X-API-KEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<GetContextSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<GetContextError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// get current context
pub async fn get_current_context(configuration: &Configuration, ) -> Result<ResponseContent<GetCurrentContextSuccess>, Error<GetCurrentContextError>> {

    let uri_str = format!("{}/context", build_url(configuration));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref value) = configuration.api_key {
        req_builder = req_builder.header("X-API-KEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<GetCurrentContextSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<GetCurrentContextError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_ingress(configuration: &Configuration, domain: &str, uri: &str, scope: &str) -> Result<ResponseContent<GetIngressSuccess>, Error<GetIngressError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_domain = domain;
    let p_uri = uri;
    let p_scope = scope;

    let uri_str = format!("{}/ingress/{domain}/{uri}", build_url(configuration), domain=crate::apis::urlencode(p_domain), uri=crate::apis::urlencode(p_uri));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("scope", &p_scope.to_string())]);
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref value) = configuration.api_key {
        req_builder = req_builder.header("X-API-KEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<GetIngressSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<GetIngressError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_root_ingress(configuration: &Configuration, domain: &str, scope: &str) -> Result<ResponseContent<GetRootIngressSuccess>, Error<GetRootIngressError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_domain = domain;
    let p_scope = scope;

    let uri_str = format!("{}/ingress/{domain}/", build_url(configuration), domain=crate::apis::urlencode(p_domain));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("scope", &p_scope.to_string())]);
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref value) = configuration.api_key {
        req_builder = req_builder.header("X-API-KEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<GetRootIngressSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<GetRootIngressError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_task_history(configuration: &Configuration, task_id: &str) -> Result<ResponseContent<GetTaskHistorySuccess>, Error<GetTaskHistoryError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_task_id = task_id;

    let uri_str = format!("{}/task/{task_id}", build_url(configuration), task_id=crate::apis::urlencode(p_task_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref value) = configuration.api_key {
        req_builder = req_builder.header("X-API-KEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<GetTaskHistorySuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTaskHistoryError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// issue a certificate -  if no certificate exists a new one is issued, if a certificate exists a new one will only be issued 3 days before its expiration 
pub async fn issue_certificate(configuration: &Configuration, issue_certificate_request: Option<models::IssueCertificateRequest>) -> Result<ResponseContent<IssueCertificateSuccess>, Error<IssueCertificateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_issue_certificate_request = issue_certificate_request;

    let uri_str = format!("{}/certificate", build_url(configuration));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref value) = configuration.api_key {
        req_builder = req_builder.header("X-API-KEY", value);
    };
    req_builder = req_builder.json(&p_issue_certificate_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<IssueCertificateSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<IssueCertificateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn list_available_contexts(configuration: &Configuration, ) -> Result<ResponseContent<ListAvailableContextsSuccess>, Error<ListAvailableContextsError>> {

    let uri_str = format!("{}/identity/availableContexts", build_url(configuration));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref value) = configuration.api_key {
        req_builder = req_builder.header("X-API-KEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<ListAvailableContextsSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<ListAvailableContextsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn list_chat(configuration: &Configuration, ) -> Result<ResponseContent<ListChatSuccess>, Error<ListChatError>> {

    let uri_str = format!("{}/chat", build_url(configuration));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref value) = configuration.api_key {
        req_builder = req_builder.header("X-API-KEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<ListChatSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<ListChatError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn list_ingress(configuration: &Configuration, scope: &str) -> Result<ResponseContent<ListIngressSuccess>, Error<ListIngressError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_scope = scope;

    let uri_str = format!("{}/ingress", build_url(configuration));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("scope", &p_scope.to_string())]);
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref value) = configuration.api_key {
        req_builder = req_builder.header("X-API-KEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<ListIngressSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<ListIngressError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn pull_task_from_queue(configuration: &Configuration, pull_task_from_queue_request: Option<models::PullTaskFromQueueRequest>) -> Result<ResponseContent<PullTaskFromQueueSuccess>, Error<PullTaskFromQueueError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pull_task_from_queue_request = pull_task_from_queue_request;

    let uri_str = format!("{}/task", build_url(configuration));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref value) = configuration.api_key {
        req_builder = req_builder.header("X-API-KEY", value);
    };
    req_builder = req_builder.json(&p_pull_task_from_queue_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<PullTaskFromQueueSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<PullTaskFromQueueError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn update_chat(configuration: &Configuration, chat_id: &str, create_chat_request: Option<models::CreateChatRequest>) -> Result<ResponseContent<UpdateChatSuccess>, Error<UpdateChatError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_chat_id = chat_id;
    let p_create_chat_request = create_chat_request;

    let uri_str = format!("{}/chat/{chat_id}", build_url(configuration), chat_id=crate::apis::urlencode(p_chat_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref value) = configuration.api_key {
        req_builder = req_builder.header("X-API-KEY", value);
    };
    req_builder = req_builder.json(&p_create_chat_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<UpdateChatSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateChatError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// update context
pub async fn update_context(configuration: &Configuration, context_id: &str, create_context_request: Option<models::CreateContextRequest>) -> Result<ResponseContent<UpdateContextSuccess>, Error<UpdateContextError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_context_id = context_id;
    let p_create_context_request = create_context_request;

    let uri_str = format!("{}/context/{context_id}", build_url(configuration), context_id=crate::apis::urlencode(p_context_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref value) = configuration.api_key {
        req_builder = req_builder.header("X-API-KEY", value);
    };
    req_builder = req_builder.json(&p_create_context_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<UpdateContextSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateContextError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

